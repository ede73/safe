package fi.iki.ede.oisafecompatibility

import android.util.Log
import fi.iki.ede.crypto.EncryptedPassword
import fi.iki.ede.crypto.HexString
import fi.iki.ede.crypto.Password
import fi.iki.ede.crypto.Salt
import fi.iki.ede.crypto.SaltedPassword
import fi.iki.ede.crypto.hexToByteArray
import fi.iki.ede.crypto.toHexString
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.PBEParameterSpec


/**
 * Crypto helper class.
 *
 *
 * Basic crypto class that uses Bouncy Castle Provider to
 * encrypt/decrypt data using PBE (Password Based Encryption) via
 * 128Bit AES. I'm fairly new to both Crypto and Java so if you
 * notice I've done something terribly wrong here please let me
 * know.
 *
 * All methods throw CryptoHelperException on failure, so prepare for that
 */
@Deprecated("Just for backwards compatibility")
open class OISafeCryptoHelper(private val algorithm: Algorithm) {
    // TODO: Iteration count is ridiculously small
    private val keyIterationCount = 20
    private var pbeParamSpec: PBEParameterSpec? = null
    private var secretKey: SecretKey? = null
    private var cipher: Cipher? = null
    private var keyFac: SecretKeyFactory? = null
    private var salt: ByteArray? = null

    /**
     * Initialize the class.  Sets the encryption level for the instance and generates the secret key factory.
     *
     * TODO: Make sure init is only called once
     */
    fun init(saltedPassword: SaltedPassword) {
        require(saltedPassword.salt.salt.size == 8) { "Salt must be exactly 8 bytes, was ${saltedPassword.salt.salt.size}" }
        require(!saltedPassword.password.isEmpty()) { "Password must not be empty!" }
        setSalt(saltedPassword.salt)

        // Java side required IV (we'll use static since salt/key are random(well key...)
        // and "java side" because running crypto tests as UNIT TESTS
        // android side does not require iv, ivSpec (bouncycastle at least)
        pbeParamSpec = PBEParameterSpec(
            salt,
            keyIterationCount,
            IvParameterSpec(byteArrayOf(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
        )
        keyFac = SecretKeyFactory.getInstance(algorithm.algorithm)
        setPassword(saltedPassword.password)
    }

    /**
     * Set the password to be used as an encryption key
     *
     * @param plaintextPasswordNotStored - might be a user-entered key, or one generated by generateMasterKey.
     */
    private fun setPassword(plaintextPasswordNotStored: Password) {
        check(keyFac != null) { "KeyFactory MUST have been set" }
        require(!plaintextPasswordNotStored.isEmpty()) { "Password must not be empty" }
        val pbeKeySpec = PBEKeySpec(plaintextPasswordNotStored.toCharArray())
        secretKey = keyFac!!.generateSecret(pbeKeySpec)
        cipher = Cipher.getInstance(algorithm.algorithm)
        assert(secretKey != null) { "Secretkey failed to initialize" }
        assert(cipher != null) { "Cipher failed to initialize" }
    }

    private fun setSalt(saltIn: Salt) {
        require(!saltIn.isEmpty()) { "Salt must be provided!" }
        require(saltIn.salt.size == 8) { "Salt must be 8 bytes in length." }
        salt = saltIn.salt
    }

//    fun encrypt(password: Password): EncryptedPassword {
//        return EncryptedPassword(encrypt(password.password).hexToByteArray())
//    }

    fun encrypt(plaintext: String): HexString {
        return encrypt(plaintext.toByteArray())
    }

    fun encrypt(plaintextArray: ByteArray): HexString {
        check(secretKey != null) { "Must call setPassword before running decrypt." }
        check(salt != null) { "Must call setSalt before running decrypt." }
        if (DEBUG && plaintextArray.isEmpty()) {
            Log.e(TAG, "Encrypting empty plaintext. You should fix call site and skip these")
        }
        cipher!!.init(Cipher.ENCRYPT_MODE, secretKey, pbeParamSpec)
        val ciphertext = cipher!!.doFinal(plaintextArray)
        return ciphertext!!.toHexString()
    }

    fun decrypt(encryptedPassword: EncryptedPassword): Password {
        return Password(decrypt(encryptedPassword.encryptedPassword))
    }

    fun decrypt(hexCipherText: HexString): ByteArray {
        return decrypt(hexCipherText.hexToByteArray())
    }

    private fun decrypt(cipherText: ByteArray): ByteArray {
        check(secretKey != null) { "Must call setPassword before running decrypt." }
        check(salt != null) { "Must call setSalt before running decrypt." }
        if (cipherText.isEmpty()) {
            return byteArrayOf()
        }
        cipher!!.init(Cipher.DECRYPT_MODE, secretKey, pbeParamSpec)
        return cipher!!.doFinal(cipherText)
    }

    companion object {
        private const val DEBUG = true
        private const val TAG = "CryptoHelper"
//        fun generateMasterKey(): Password {
//            val keygen = KeyGenerator.getInstance("AES")
//            keygen.init(256)
//            return Password(keygen.generateKey().encoded)
//        }

        fun generateSalt(): Salt {
            val salt = ByteArray(8)
            // TODO: https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html ?
            val sr = SecureRandom()
            sr.nextBytes(salt)
            return Salt(salt)
        }
    }
}